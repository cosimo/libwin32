<HTML>
<HEAD>
<TITLE>Win32::API - Perl Win32 API Import Facility</TITLE>
<LINK REV="made" HREF="mailto:">
</HEAD>

<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A></LI>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A></LI>
	<LI><A HREF="#ABSTRACT">ABSTRACT</A></LI>
	<LI><A HREF="#CREDITS">CREDITS</A></LI>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A></LI>
	<UL>

		<LI><A HREF="#IMPORTING_A_FUNCTION">IMPORTING A FUNCTION</A></LI>
		<LI><A HREF="#CALLING_AN_IMPORTED_FUNCTION">CALLING AN IMPORTED FUNCTION</A></LI>
	</UL>

	<LI><A HREF="#AUTHOR">AUTHOR</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
Win32::API - Perl Win32 API Import Facility

</P>
<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
<PRE>  use Win32::API;
  $function = new Win32::API(
      $library, $functionname, \@argumenttypes, $returntype,
  );
  $return = $function-&gt;Call(@arguments);
</PRE>
</P>
<P>
<HR>
<H1><A NAME="ABSTRACT">ABSTRACT</A></H1>
<P>
With this module you can import and call arbitrary functions from Win32's
Dynamic Link Libraries (DLL), without having to write an XS extension.
Note, however, that this module can't do anything (parameters input and
output is limited to simpler cases), and anyway a regular XS extension is
always safer and faster. 

</P>
<P>
The current version of Win32::API is available at my website:

</P>
<P>
<PRE>  <A HREF="http://dada.perl.it/">http://dada.perl.it/</A>
</PRE>
</P>
<P>
It's also available on your nearest CPAN mirror (but allow a few days for
worldwide spreading of the latest version) reachable at:

</P>
<P>
<PRE>  <A HREF="http://www.perl.com/CPAN/authors/Aldo_Calpini/">http://www.perl.com/CPAN/authors/Aldo_Calpini/</A>
</PRE>
</P>
<P>
A short example of how you can use this module (it just gets the PID of the
current process, eg. same as Perl's internal <CODE>$$</CODE>):

</P>
<P>
<PRE>    use Win32::API;
    $GetPID = new Win32::API(&quot;kernel32&quot;, &quot;GetCurrentProcessId&quot;, '', 'N');
    $PID = $GetPID-&gt;Call();
</PRE>
</P>
<P>
The possibilities are nearly infinite (but not all are good :-). Enjoy it.

</P>
<P>
<HR>
<H1><A NAME="CREDITS">CREDITS</A></H1>
<P>
All the credits go to Andrea Frosini for the neat assembler trick that
makes this thing work. A big thank you also to Gurusamy Sarathy for his
unvaluable help in XS development, and to all the Perl community for being
what it is.

</P>
<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
To use this module put the following line at the beginning of your script:

</P>
<P>
<PRE>    use Win32::API;
</PRE>
</P>
<P>
You can now use the <CODE>new()</CODE> function of the Win32::API module to create a new API object (see <A HREF="#IMPORTING_A_FUNCTION">IMPORTING A FUNCTION</A>) and then invoke the 
<CODE>Call()</CODE> method on this object to perform a call to the imported API (see <A HREF="#CALLING_AN_IMPORTED_FUNCTION">CALLING AN IMPORTED FUNCTION</A>).

</P>
<P>
<HR>
<H2><A NAME="IMPORTING_A_FUNCTION">IMPORTING A FUNCTION</A></H2>
<P>
You can import a function from a 32 bit Dynamic Link Library (DLL) file
with the <CODE>new()</CODE> function. This will create a Perl object that contains the reference to
that function, which you can later <CODE>Call()</CODE>. You need to pass 4 parameters:

</P>
<OL>
<LI><STRONG><A NAME="item_The_name_of_the_library_from_whi">The name of the library from which you want to import the function.</A></STRONG>
<LI><STRONG><A NAME="item_The_name_of_the_function_as_exp">The name of the function (as exported by the library).</A></STRONG>
<LI><STRONG><A NAME="item_The_number_and_types_of_the_argu">The number and types of the arguments the function expects as input.</A></STRONG>
<LI><STRONG><A NAME="item_The_type_of_the_value_returned_b">The type of the value returned by the function.</A></STRONG>
</OL>
<P>
To better explain their meaning, let's suppose that we want to import and
call the Win32 API <CODE>GetTempPath()</CODE>. This function is defined in C as:

</P>
<P>
<PRE>    DWORD WINAPI GetTempPathA( DWORD nBufferLength, LPSTR lpBuffer );
</PRE>
</P>
<P>
This is documented in the <STRONG>Win32 SDK Reference</STRONG>; you can look for it on the Microsoft's WWW site, or in your C compiler's
documentation, if you own one.

</P>
<OL>
<LI><STRONG><A NAME="item__">.</A></STRONG>
<P>
The first parameter is the name of the library file that exports this
function; our function resides in the <EM>KERNEL32.DLL</EM>
system file. When specifying this name as parameter, the <EM>.DLL</EM> extension is implicit, and if no path is given, the file is searched
through a couple of directories, including: 

</P>
<OL>
<LI><STRONG><A NAME="item_The_directory_from_which_the_app">The directory from which the application loaded.</A></STRONG>
<LI><STRONG><A NAME="item_The_current_directory_">The current directory.</A></STRONG>
<LI><STRONG><A NAME="item_The_Windows_system_directory_eg">The Windows system directory (eg. c:\windows\system or system32).</A></STRONG>
<LI><STRONG><A NAME="item_The_Windows_directory_eg_c_wi">The Windows directory (eg. c:\windows).</A></STRONG>
<LI><STRONG><A NAME="item_The_directories_that_are_listed_">The directories that are listed in the PATH environment variable.</A></STRONG>
</OL>
<P>
So, you don't have to write <EM>C:\windows\system\kernel32.dll</EM>; only <EM>kernel32</EM> is enough:

</P>
<P>
<PRE>    $GetTempPath = new Win32::API('kernel32', ...
</PRE>
</P>
<LI><STRONG>.</STRONG>
<P>
Now for the second parameter: the name of the function. It must be written
exactly as it is exported by the library (case is significant here). If you
are using Windows 95 or NT 4.0, you can use the <STRONG>Quick View</STRONG> 
command on the DLL file to see the function it exports. Remember that you
can only import functions from 32 bit DLLs: in Quick View, the file's
characteristics should report somewhere ``32 bit word machine''; as a rule
of thumb, when you see that all the exported functions are in upper case,
the DLL is a 16 bit one and you can't use it. If their capitalization looks
correct, then it's probably a 32 bit DLL.

</P>
<P>
Also note that many Win32 APIs are exported twice, with the addition of a
final <STRONG>A</STRONG> or <STRONG>W</STRONG> to their name, for - respectively - the ASCII and the Unicode version. When
a function name is not found, Win32::API will actually append an <STRONG>A</STRONG> to the name and try again; if the extension is built on a Unicode system,
then it will try with the <STRONG>W</STRONG> instead. So our function name will be:

</P>
<P>
<PRE>    $GetTempPath = new Win32::API('kernel32', 'GetTempPath', ...
</PRE>
</P>
<P>
In our case <CODE>GetTempPath</CODE> is really loaded as <CODE>GetTempPathA</CODE>.

</P>
<LI><STRONG>.</STRONG>
<P>
The third parameter, the input parameter list, specifies how many arguments
the function wants, and their types. It can be passed as a single string,
in which each character represents one parameter, or as a list reference.
The following forms are valid:

</P>
<P>
<PRE>    &quot;abcd&quot;
    [a, b, c, d]
    \@LIST
</PRE>
</P>
<P>
But those are not:

</P>
<P>
<PRE>    (a, b, c, d)
    @LIST
</PRE>
</P>
<P>
The number of characters, or elements in the list, specifies the number of
parameters, and each character or element specifies the type of an
argument; allowed types are:

</P>
<DL>
<DT><STRONG><A NAME="item_I">I: 
value is an integer</A></STRONG><DD>
<DT><STRONG><A NAME="item_N">N: 
value is a number (long)</A></STRONG><DD>
<DT><STRONG><A NAME="item_F">F: 
value is a floating point number (float)</A></STRONG><DD>
<DT><STRONG><A NAME="item_D">D: 
value is a double precision number (double)</A></STRONG><DD>
<DT><STRONG><A NAME="item_P">P: 
value is a pointer (to a string, structure, etc...)</A></STRONG><DD>
</DL>
<P>
Our function needs two parameters: a number (<CODE>DWORD</CODE>) and a pointer to a string (<CODE>LPSTR</CODE>):

</P>
<P>
<PRE>    $GetTempPath = new Win32::API('kernel32', 'GetTempPath', 'NP', ...
</PRE>
</P>
<LI><STRONG>.</STRONG>
<P>
The fourth and final parameter is the type of the value returned by the
function. It can be one of the types seen above, plus another type named <STRONG>V</STRONG> 
(for <CODE>void</CODE>), used for functions that do not return a value. In our example the value
returned by <CODE>GetTempPath()</CODE> is a <CODE>DWORD</CODE>, so our return type will be <STRONG>N</STRONG>:

</P>
<P>
<PRE>    $GetTempPath = new Win32::API('kernel32', 'GetTempPath', 'NP', 'N');
</PRE>
</P>
<P>
Now the line is complete, and the <CODE>GetTempPath()</CODE> API is ready
to be used in Perl. Before calling it, you should test that
<CODE>$GetTempPath</CODE> is 
<CODE>defined</CODE>, otherwise either the function or the library could not be loaded; in this
case, <CODE>$!</CODE> will be set to the error message reported by Windows. Our definition, with
error checking added, should then look like this:

</P>
<P>
<PRE>    $GetTempPath = new Win32::API('kernel32', 'GetTempPath', 'NP', 'N');
    if(not defined $GetTempPath) {
        die &quot;Can't import API GetTempPath: $!\n&quot;;
    }
</PRE>
</P>
</OL>
<P>
<HR>
<H2><A NAME="CALLING_AN_IMPORTED_FUNCTION">CALLING AN IMPORTED FUNCTION</A></H2>
<P>
To effectively make a call to an imported function you must use the
<CODE>Call()</CODE> method on the Win32::API object you created. Continuing
with the example from the previous paragraph, the
<CODE>GetTempPath()</CODE> API can be called using the method:

</P>
<P>
<PRE>    $GetTempPath-&gt;Call(...
</PRE>
</P>
<P>
Of course, parameters have to be passed as defined in the import phase. In
particular, if the number of parameters does not match (in the example, if
<CODE>GetTempPath()</CODE> is called with more or less than two
parameters), Perl will <CODE>croak</CODE> an error message and <CODE>die</CODE>.

</P>
<P>
The two parameters needed here are the length of the buffer that will hold
the returned temporary path, and a pointer to the buffer itself. For
numerical parameters, you can use either a constant expression or a
variable, while <STRONG>for pointers you must use a variable name</STRONG> (no Perl references, just a plain variable name). Also note that <STRONG>memory must be allocated before calling the function</STRONG>, just like in C. For example, to pass a buffer of 80 characters to
<CODE>GetTempPath(),</CODE> it must be initialized before with:

</P>
<P>
<PRE>    $lpBuffer = &quot; &quot; x 80;
</PRE>
</P>
<P>
This allocates a string of 80 characters. If you don't do so, you'll
probably get <CODE>Runtime exception</CODE> errors, and generally nothing will work. The call should therefore include:

</P>
<P>
<PRE>    $lpBuffer = &quot; &quot; x 80;
    $GetTempPath-&gt;Call(80, $lpBuffer);
</PRE>
</P>
<P>
And the result will be stored in the <CODE>$lpBuffer</CODE> variable. Note
that you don't need to pass a reference to the variable (eg. you <STRONG>don't need</STRONG>  <CODE>\$lpBuffer</CODE>), even if its value will be set by the function. 

</P>
<P>
A little problem here is that Perl does not trim the variable, so
<CODE>$lpBuffer</CODE> will still contain 80 characters in return; the
exceeding characters will be spaces, because we said <CODE>&quot; &quot; x 80</CODE>.

</P>
<P>
In this case we're lucky enough, because the value returned by the
<CODE>GetTempPath()</CODE> function is the length of the string, so to get
the actual temporary path we can write:

</P>
<P>
<PRE>    $lpBuffer = &quot; &quot; x 80;
    $return = $GetTempPath-&gt;Call(80, $lpBuffer);
    $TempPath = substr($lpBuffer, 0, $return);
</PRE>
</P>
<P>
If you don't know the length of the string, you can usually cut it at the <CODE>\0</CODE> (ASCII zero) character, which is the string delimiter in C:

</P>
<P>
<PRE>    $TempPath = ((split(/\0/, $lpBuffer))[0];
    
    # or
    
    $lpBuffer =~ s/\0.*$//;
</PRE>
</P>
<P>
Another note: to pass a pointer to a structure in C, you have to
<CODE>pack()</CODE> the required elements in a variable. And of course, to
access the values stored in a structure, <CODE>unpack()</CODE> it as
required. A short example of how it works: the <CODE>POINT</CODE> structure is defined in C as:

</P>
<P>
<PRE>    typedef struct {
        LONG  x;
        LONG  y;
    } POINT;
</PRE>
</P>
<P>
Thus, to call a function that uses a <CODE>POINT</CODE> structure you need the following lines:

</P>
<P>
<PRE>    $GetCursorPos = new Win32::API('user32', 'GetCursorPos', 'P', 'V');
    
    $lpPoint = pack('LL', 0, 0); # store two LONGs
    $GetCursorPos-&gt;Call($lpPoint);
    ($x, $y) = unpack('LL', $lpPoint); # get the actual values
</PRE>
</P>
<P>
The rest is left as an exercise to the reader...

</P>
<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR</A></H1>
<P>
Aldo Calpini ( <EM>dada@perl.it</EM> ).

</P>

</BODY>

</HTML>
